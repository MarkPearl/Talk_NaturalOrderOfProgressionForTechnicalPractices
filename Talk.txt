Im not addressing this talk to everyone. Some of you in this room have solved this problem already and I applaud you for this. In fact, you just showing up today puts you ahead of the curve. That said, I want to talk about a problem I have seen in this industry often that we are not dealing with.

When I had my thirteenth birthday, my parents bought me a skateboard. This wasn't your ordinary plain shaped skateboard. The deck on this skateboard was what we would call a cruizer deck. It was aerodynamic and was about the coolest skateboard I had ever seen. Being a thirteen year old, I decided I was going to be one of the world's greatest skateboarders. After trying my hand at a few tricks and failing hopelessly, I came up with a plan B, I would be known for speed. In search of world fame, I walked around my neighborhood to find a suitable hill to ride. Having grown up in a place called Forest Hills in KwaZulu Natal, this wasn't a hard problem to solve. About a block away from my house I found what I thought would be a decent road (Regent Rd) going down a hill. I told my brothers to watch this, and pushed off on the skateboard down the hill. About 5 meters down the hill I realized I hadn't really thought this through - I was picking up speed quickly, had no protective gear on. Oh, and at the bottom of the hill was a T junction - with the hill being the "dead" end of the T junction with cars driving in either direction with no view of anyone coming down the hill. With no other option, I did what any other thriteen year old would do in that situation - I jumped off my board, the skateboard  continued down the hill for a few meters and so did I. To this day, I still remember clearly standing up, looking down at my knees and hands where just moments ago there was healthy skin - now replaced with a lot of missing skin and a sudden a rush a blood and searing pain. That was to be one of the shortest careers a skateboarded would ever have. I just wasn't ready for that kind of speed.



In this world where we talk about going or being agile I am concerned that a misconception is occuring. There is a massive focus on making our people and business interactions more effective. We talk about agile embracing change, how we want to avoid fixed documents that slow us down, how we want to be more flexible in planning and change direction or pivot quickly. The problem is, someone has to actually implement these changes and unless those people can keep up, you changing things can make it worse. 

This is all great, and I'm seeing in a lot of organizations very little focus on aligning our engineering practices with this mindset. The reality is, just because you change your mind or discover a new aspect of the problem you are trying to solve - this doesn't mean that at a technical level you are equiped to change direction. you wont' realize the true value of agile until you embrace engineering practices that algin with this.

So how have we, and the agile methodologies we embrace helped contribute to this problem? I'm seeing a ton of courses on Scrum and Kanban being offered. Lots of business people being sold on the concept and very little effort put at the engineering side. In fact, if you read up on two of the most popular agile methodologies - Scrum and Kanban - they don't officially recommend an specific engineering practices.

So, before we can decide what engineering practices to start with, we first need to identify what engineering practices we should be considering. In an attempt to get a list of engineering practices I resorted to a few public forums to get feedback from people in the industry what they felt technical practices were. The responses were interesting.

Straight out the gate I got Test Driven Development, Pair Programming, Continous Integration, Continous Deployment and Acceptance Test Driven Development from Sam (@samlaing). Soon to follow was a great email explaining that it meant keeping to short schedules and being able to adapt quickly. Following that I got a response from Kevin saying it was XP - which would mean Collective Ownership, Collective Coding Standard, Simple Design, Refactoring, Writing Tests, Pair Programming & Continous Integration. I also got mentions of Just-In-Time Architecture & Design, close collaboration between business, devs, UI/UX and testers.

As I began to receive this feedback, it became more and more apparent that I would not be able to introduce these topics at any level in 30 minutes, let alone prioritize them. Even if I could, I'm cognisant that each team I have come across is a unique composition of people, and so what would work in one team may not work in another. 

So, to simplify the problem, I've decided to take give a specific scenario, talk through how I would approach that and then try and give you some principles to apply this to your own organiazation.

The scenario I came up with is as follows: There is a group that has been releasing software occaisonally. The group is called the Dev team - they consist of 8 developers and one dev manager. The Dev teams responsibility is to maintain a legacy system that business has been using for the last ten years. Because the business uses the system for everything, they are always wanting additional features added to the system. They do this via logging projects. If a project is really large it gets assigned a business analyst who generates the requirements, otherwise it is investigated by the Dev Manager who assigns the work. When work comes in a devleoper in our group is assigned the work based on the area of the system it effects. For instance, Gill is the expert for invoicing and handles any work related to that aspect of the solution, Mike handles amortization schedules, Bob handles all Foo requests. We try and release every quarter, but getting things ready for production is a lot of work and so Dave who does the release package usually only gets an acceptable version out after a few weeks of going back and forth between the testers. The team works hard, but is always under pressure from business who is putting pressure on getting delivery of features.

So, I'm interested to find out, who at some stage in the career has worked in this team or a team similar to this

So where do we start?

If I was brought onto this team, there are two questions I would ask:
How fast do you want to go?
How much slack can you create?

I am going to deal with these first before I outline the practices:

How fast do you want to go is really important. 

The speed you want to go largely effects the structure of your team and the practices you embrace. It is painful expect a team that was previously delivering in to production once every six months can suddenly move to delivering to production once a week for two main reasons - different speeds require different team structures. The skills required for a group to release to production once every six months is very different to a team that is releasing in to production once a month and likewise once a day. Also, every structure resists change - organizations have a built in immune systems - they fight off change. If you organization is a 6 month release organization, it may be politically very challenging to have a once a week release team work within it unless it has by in from the top.


So, a few things I want to set out
- every practice has a jcurve (when learning something new, productivity dips before it improves)
- some practices return minimum value unless coupled with other practices
- practices need to be sustainable during pressure situations (teams without these practices are often in pressure situaitons a lot)

With that said, I know that every team is a unique snow flake. I understand that what I will be sharing might not map one to one with your teams exact situation. I would love to find out the specifics of the pain you are facing afterwards.


How much slack does your team have? When I talk about slack, I am refering to the time a team has to improving their process and upskilling. Having slack is vital to adopting new practices. Teams that don't have slack do not have capacity to change. Having slack built in as a regular cadence into your process is vital for continued improvement. I'm a proponent of teams doing intential improvement on at worst a weekly cadence.

The first thing I like to find out from a team is how often they are releasing to production?

Generally I find teams release to production a lot less frequently than they should. For a lot of teams it is once every few months. 


Essentially when I am developing software I want feedback at every level. The quicker the feedback the better. I want feedback when I am solving a problem to know if it is the right problem to solve. I want feedback when I am coding to know if my approach is right. I want feedback when I release to know if everything is working properly. The quicker I can get this feedback, the better position I am in.


First we need to decide how fast we want to go. I watched a wonderful talk done by Kent Beck on GForces and how teams change shape depending on their speed. Determining how fast you want to go


So where do we start?

The first technical practice I would like to promote is build automation. Build automation is the act of scripting or automating a wide variety of tasks that software developers do in their day-to-day activities. Anything related to compiling, packaging binaries, 

The first technical practice I would like to promote is collective code ownership.
For those that are unfamiliar with the term, collective code ownership means that everyone is responsible for all the code. This in return means that everyone is allowed to change any part of the code.
I have sometime seen people confusing version control with collective code ownership. Just because your team has their code in version control does not mean there is collective code ownership - I have seen teams have a large solution, where inside that solution they had a folder for each developer, under which they had a copy of the code. This is not collective ownership. 


Good to know
- Every practice has a J curve - can you afford to have the downtime
- Some practices return minimum value unless coupled with other practices
- Should be able to sustain practices during pressure situationo
- Legacy system testing

Other things
- Manual testing slows things down
- Learn your refactoring tools

What are agile engineering rpactices
- TDD,
- Pairing,
- Continous Integration
- Continous Deployment
- Acceptance Test Driven Developement

When it is expensive to make something, you do it less frequently. When it is cheap, you do it more often

At a principle level what we are looking for is... any practice that helps shorten feedback loops and promote sustainable pace.

## Definition ##

Engineering Practice is a specific software development practice that is proposed to be implemented by agile method.


Many think Agile is just about stand-ups & sticky notes when it is actually about being able to deliver valuable software faster. It is impossible to do this if you don't leverage the technical practices agile has embraced. The challenge is - where do you start? Do you focus your energy on understanding TDD, or put time into a continuous build environment. What is the natural order of progression and how do you implement them without slowing down feature delivery?

In this session Mark is going to present what he believes is the natural order of progression of technical practices. He will highlight some of the challenges he's faced with teams trying to increase their release rate and what they did to overcome these barriers.

This talk is appropriate for technical AND non-technical people involved in Software Development who would like to release to production more frequently (be it from Months to Weeks, Weeks to Days, or Days to Hours). Those already hitting the magical continuous release rate don't need to attend ;-)
## How is your topic relevant to an African context ##

## Keywords ##

TDD, 
Automated Deployment, 
Continuous Integration, 
Version Control, 
Automated Testing, 
Deliver Faster

## Learning Outcomes ##
Understand the order of implementing technical practices
Understand why each technical practice is valuable
Understand how long each technical practice usually takes to embrace or see a return on
Debunk potential myths on why one technical practice will solve all your problems

References - Agile Engineering Practices (http://blogs.versionone.com/agile_management/2013/07/10/agile-engineering-practices-a-cheat-sheet/)  

Potential Engineering Practices
- Pair Programming
- Test Driven Design
- Automated Acceptance Testing
- Refactoring
- Emergent Design
- Continuous Integration
- Shared code repository

References - Agile Egineering Best Practices - http://www.slideshare.net/RichardChengExcella/agile-engineering-best-practices-what-every-project-manager-should-know?next_slideshow=1

Do this first...
- Version control
- Build automation
- Automated unit testing
- Continous integration
- Static code analysis
- Dependency Management
- Automated integration testing
- Automated acceptance testing
- Deployment automation

References - Benefit of agile engineering practices - http://www.infoq.com/articles/benefit-agile-engineering

https://blog.codecentric.de/en/2014/05/agile-engineering-practices-short-overview/

Videos on egile engineering practices
http://shop.oreilly.com/product/0636920020271.do

Why did we lose the XP practices (https://coding.abel.nu/2014/04/why-did-we-lose-the-xp-practices/)
